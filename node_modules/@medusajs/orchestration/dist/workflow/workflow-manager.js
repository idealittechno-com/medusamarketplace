"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowManager = void 0;
const transaction_1 = require("../transaction");
class WorkflowManager {
    static unregister(workflowId) {
        WorkflowManager.workflows.delete(workflowId);
    }
    static unregisterAll() {
        WorkflowManager.workflows.clear();
    }
    static getWorkflows() {
        return WorkflowManager.workflows;
    }
    static getWorkflow(workflowId) {
        return WorkflowManager.workflows.get(workflowId);
    }
    static getTransactionDefinition(workflowId) {
        if (!WorkflowManager.workflows.has(workflowId)) {
            throw new Error(`Workflow with id "${workflowId}" not found.`);
        }
        const workflow = WorkflowManager.workflows.get(workflowId);
        return new transaction_1.OrchestratorBuilder(workflow.flow_);
    }
    static register(workflowId, flow, handlers, requiredModules, optionalModules) {
        const finalFlow = flow instanceof transaction_1.OrchestratorBuilder ? flow.build() : flow;
        if (WorkflowManager.workflows.has(workflowId)) {
            const areStepsEqual = JSON.stringify(finalFlow) ===
                JSON.stringify(WorkflowManager.workflows.get(workflowId).flow_);
            if (!areStepsEqual) {
                throw new Error(`Workflow with id "${workflowId}" and step definition already exists.`);
            }
        }
        WorkflowManager.workflows.set(workflowId, {
            id: workflowId,
            flow_: finalFlow,
            orchestrator: new transaction_1.TransactionOrchestrator(workflowId, finalFlow),
            handler: WorkflowManager.buildHandlers(handlers),
            handlers_: handlers,
            requiredModules,
            optionalModules,
        });
    }
    static update(workflowId, flow, handlers, requiredModules, optionalModules) {
        if (!WorkflowManager.workflows.has(workflowId)) {
            throw new Error(`Workflow with id "${workflowId}" not found.`);
        }
        const workflow = WorkflowManager.workflows.get(workflowId);
        for (const [key, value] of handlers.entries()) {
            workflow.handlers_.set(key, value);
        }
        const finalFlow = flow instanceof transaction_1.OrchestratorBuilder ? flow.build() : flow;
        WorkflowManager.workflows.set(workflowId, {
            id: workflowId,
            flow_: finalFlow,
            orchestrator: new transaction_1.TransactionOrchestrator(workflowId, finalFlow),
            handler: WorkflowManager.buildHandlers(workflow.handlers_),
            handlers_: workflow.handlers_,
            requiredModules,
            optionalModules,
        });
    }
    static buildHandlers(handlers) {
        return (container, context) => {
            return async (actionId, handlerType, payload, transaction) => {
                const command = handlers.get(actionId);
                if (!command) {
                    throw new Error(`Handler for action "${actionId}" not found.`);
                }
                else if (!command[handlerType]) {
                    throw new Error(`"${handlerType}" handler for action "${actionId}" not found.`);
                }
                const { invoke, compensate, payload: input } = payload.context;
                const { metadata } = payload;
                return await command[handlerType]({
                    container,
                    payload: input,
                    invoke,
                    compensate,
                    metadata,
                    transaction: transaction,
                    context,
                });
            };
        };
    }
}
exports.WorkflowManager = WorkflowManager;
WorkflowManager.workflows = new Map();
global.WorkflowManager ?? (global.WorkflowManager = WorkflowManager);
exports.WorkflowManager = global.WorkflowManager;
//# sourceMappingURL=workflow-manager.js.map